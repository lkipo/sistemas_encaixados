1.  ## ACABAR PARTE 1. FALTA PROGRAMA 1.4###
º
1.1 --> Comentado no código
1.2 --> Comentado no código
1.3 --> O programa principal non entra no if de dentro do for, polo que entra no else 4 veces seguidas, e os outros procesos, os cales entraron na funcion fillo fan o que está escrito na funcion fillo, pero non se executa unha saída "ordenada" do programa, pois só hai un wait e hai catro procesos activos, polo que o terminal pensa que o programa finalizou antes de que realmente finaliazse e mostranse os 3 ultimos procesos despois de que aparezca visualmente a liña de comandos. Se comentamos a parte entre os comentarios //Para quitar o que sucede é que se executan waits sempre que queden procesos activos, e cando non quedan mais procesos activos, é dicir despois de que se finalize o programa principal e os 4 fillos do programa e sae do programa "ordenadamente" polo que o terminal o recoñece sen problemas.
1.4 --> jajaxd
1.5 --> Cando executamos un kill seguido do parámetro -SIGUSR1 e o pid do programa o que lle estamos decindo ao sistema é que mate ao programa co pid que lle estamos a pasar, e co parámetro -SIGUSR1 decimoslle que se invoque ao manexador de sinais que ten como identificador SIGUSR1, (o cal é un estandar) e que volva á seguinte insdtrucción do programa principal ao finalizar a función correspondente, inda que no noso programa simplemente acaba porque non hai mais instruccións ca o sleep(20).### nota -> mirar que fai pkill e engadilo

2. FreeRTOS

2.1 --> O programa ten dúas tarefas creadas sobre a mesma función, unha que se executa cun retraso de 1 segundo e outra que se executa cun retraso de medio segundo. A tarefa que se executa con 0.5s de retraso ten prioridade sobre a outra, polo que cando coincide a tarefa 1 coa tarefa 2 (cada dúas iteracións da tarefa 1 ou cada iteración da tarefa 2) a tarefa 1 executase primeiro que a tarefa 2 por ter mais prioridade. Os parametros pasanse mediante un punteiro a vacío, polo que podemos pasar o que queiramos sempre que o coñezcamos para podelo usar despois con correctamente.

2.2 --> Comentarios no código. A función vStopResume obten o handle da outra tarefa porque se pasa unha referencia cando se crea a tarefa a xHandle1, que é igual a xHandleStopResume

2.3 --> O programa alterna entre dúas tarefas S1 e S2. A espera realizase mediante un bucle for moi longo. Se cambiamos PRIORITY1 por PRIORITY2 o programa non entra na segunda tarefa, pois sempre está ocupado e atenderá sempre ás tarefas de maior prioridade en caso de que estea moi ocupado.

2.4 --> vTaskDelayUntill() é distinta a vTaskDelay() en tanto que vTaskDelay recibe como parámetro o número de ciclos de reloxo que deben transcorrer dende que se chama á función ate que a mesma tarefa volva ao estado bloqueado, mentres que vTaskDelayUntill especifica o ciclo de reloxo exacto no que a tarefa se debe mover dende Bloqueado a Listo, polo que poderíamos decir que vTaskDelay é relativa ao ciclo de reloxo no que se chama e que vTaskDelay non o é.

2.5 --> O arquivo consta de tres tarefas. Duas continuas que se executan constantemente e que se intercambian entre si de maneira caótica por ter ambas a mesma prioridade (C1 e C2) e unha terceira tarefa, P1, a cal se executa unha vez cada 3 milisegundos, e se superpón ás outras dúas tarefas por ter maior prioridade

2.6 --> Funciona inda que nunca se chame a vApplicationIdleHook porque no arquivo FreeRTOS.h o parametro configUSE_IDLE_HOOK esta posto a 1 (activado), polo que o programa entende que esa funcion se ten que utilizar.Funciona inda que nunca se chame a vApplicationIdleHook porque no arquivo FreeRTOS.h o parametro configUSE_IDLE_HOOK esta posto a 1 (activado), polo que o programa entende que esa funcion se ten que utilizar. 
