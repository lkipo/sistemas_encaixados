1.  ## ACABAR PARTE 1. FALTA PROGRAMA 1.4###
º
1.1 --> Comentado no código
1.2 --> Comentado no código
1.3 --> O programa principal non entra no if de dentro do for, polo que entra no else 4 veces seguidas, e os outros procesos, os cales entraron na funcion fillo fan o que está escrito na funcion fillo, pero non se executa unha saída "ordenada" do programa, pois só hai un wait e hai catro procesos activos, polo que o terminal pensa que o programa finalizou antes de que realmente finaliazse e mostranse os 3 ultimos procesos despois de que aparezca visualmente a liña de comandos. Se comentamos a parte entre os comentarios //Para quitar o que sucede é que se executan waits sempre que queden procesos activos, e cando non quedan mais procesos activos, é dicir despois de que se finalize o programa principal e os 4 fillos do programa e sae do programa "ordenadamente" polo que o terminal o recoñece sen problemas.
1.4 --> Primeiro executase o proceso pai, o cal entra no if. O proceso fillo espera un pouco a executarse e cando se executa a parte da tarefa que executa a funcion traballo_inutil, ao ser un proceso demandante, ocupa moita cpu, o mesmo que ocorre cando no proceso pai se chama a traballo_inutil. Cando o proceso pai termina quedase esperando a que o proceso fillo termine. Cada un dos procesos usa un core. No meu computador con 16 cores cada un dos procesos usa o 100% do seu respectivo núcleo.
1.5 --> Cando executamos un kill seguido do parámetro -SIGUSR1 e o pid do programa o que lle estamos decindo ao sistema é que mate ao programa co pid que lle estamos a pasar, e co parámetro -SIGUSR1 decimoslle que se invoque ao manexador de sinais que ten como identificador SIGUSR1, (o cal é un estandar) e que volva á seguinte insdtrucción do programa principal ao finalizar a función correspondente, inda que no noso programa simplemente acaba porque non hai mais instruccións ca o sleep(20).### nota -> mirar que fai pkill e engadilo

2. FreeRTOS

2.1 --> O programa ten dúas tarefas creadas sobre a mesma función, unha que se executa cun retraso de 1 segundo e outra que se executa cun retraso de medio segundo. A tarefa que se executa con 0.5s de retraso ten prioridade sobre a outra, polo que cando coincide a tarefa 1 coa tarefa 2 (cada dúas iteracións da tarefa 1 ou cada iteración da tarefa 2) a tarefa 1 executase primeiro que a tarefa 2 por ter mais prioridade. Os parametros pasanse mediante un punteiro a vacío, polo que podemos pasar o que queiramos sempre que o coñezcamos para podelo usar despois con correctamente.

2.2 --> Comentarios no código. A función vStopResume obten o handle da outra tarefa porque se pasa unha referencia cando se crea a tarefa a xHandle1, que é igual a xHandleStopResume

2.3 --> O programa alterna entre dúas tarefas S1 e S2. A espera realizase mediante un bucle for moi longo. Se cambiamos PRIORITY1 por PRIORITY2 o programa non entra na segunda tarefa, pois sempre está ocupado e atenderá sempre ás tarefas de maior prioridade en caso de que estea moi ocupado.

2.4 --> vTaskDelayUntill() é distinta a vTaskDelay() en tanto que vTaskDelay recibe como parámetro o número de ciclos de reloxo que deben transcorrer dende que se chama á función ate que a mesma tarefa volva ao estado bloqueado, mentres que vTaskDelayUntill especifica o ciclo de reloxo exacto no que a tarefa se debe mover dende Bloqueado a Listo, polo que poderíamos decir que vTaskDelay é relativa ao ciclo de reloxo no que se chama e que vTaskDelay non o é.

2.5 --> O arquivo consta de tres tarefas. Duas continuas que se executan constantemente e que se intercambian entre si de maneira caótica por ter ambas a mesma prioridade (C1 e C2) e unha terceira tarefa, P1, a cal se executa unha vez cada 3 milisegundos, e se superpón ás outras dúas tarefas por ter maior prioridade

2.6 --> Funciona inda que nunca se chame a vApplicationIdleHook porque no arquivo FreeRTOS.h o parametro configUSE_IDLE_HOOK esta posto a 1 (activado), polo que o programa entende que esa funcion se ten que utilizar.Funciona inda que nunca se chame a vApplicationIdleHook porque no arquivo FreeRTOS.h o parametro configUSE_IDLE_HOOK esta posto a 1 (activado), polo que o programa entende que esa funcion se ten que utilizar. 

3. IPC

3.1.1 --> Ao executar o productor basico comprobase que os obxectos compartidos de memoria se creasen correctamente, despois mapease a memoria compartida con dous punteiros que, inicialmente apuntan a null. Despois inicializase o buffer completo a -1 e chamase á funcion productor(), onde se entra a un bucle infinito que cada dez veces que se executa quedase parado no if, onde seguirá mentras non se execute o o consumidor e se cambie o valor do contador a outro que non sexa 10. Na execución do consumidor comprobase que se creasen correctamente os elementos de memoria compartido e mapease con punteiros que, ao igual que antes, apuntan a null.

3.2.1 --> sem_post() decrementa o valor do semaforo ao que se apunta e sem_wait() incrementao. Primeiro comprobanse que os elementos compartidos de memoria se creasen correctamente. Logo ao chamar a productor entrase nun bucle que produce elementos á vez que se decrementa o semaforo vacío e se incrementa o cheo seguindo o proceso ate que o cheo chegue a 0 (e o vacío a 10). Ahí executase de novo o produtor e así sucesivamente ate que o for finalize. Cando o for finaliza, o produtor elimina os elementos despois de comprobar que non estan sendo usados.
3.2.2 --> Nesta version en vez de acceder ao buffer co valor do punteuro usase a funcion sem_getvalue() para coller o seu valor. O programa falla xa que a veces o consumidor elimina algún -1. sem_getvalue colle o valor dun semaforo. 

3.4 --> main_blinky() crea unha cola, un temporizador e dúas tarefas, unha das cales, prvQueueReciveTask() fai a recepción da cola, espeando a que cheguen datos. Cando os recibe verifica o seu valor e xenera unha mensaxe para indicar se os datos veñen da tarefa de envío de cola ou do temporizador de software. O temporizador de software recarda automáticamente cun período de dous segundos. A función prvQueueSendTimerCallback() escrebe o valor 200 na cola. O temporizador resetease cada vez que pulsamos unha tecla. As tarefas comunícanse empregando a cola, a cal actua como memoria compartida por ambos. Ao recibir un dato a tarefa bloquease ate que a cola volva a estar vacía.
